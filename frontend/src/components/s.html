<div class="sidebar">
    <h4 class="mb-3">–£—á–∞—Å—Ç–æ–∫</h4>
    <div class="d-flex gap-2 mb-2">
        <button id="drawPolygon" class="btn btn-primary flex-grow-1">–ó–∞–¥–∞—Ç—å —É—á–∞—Å—Ç–æ–∫</button>
        <button id="editCoordinates" class="btn btn-warning" title="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã" style="min-width: 50px; font-size: 18px; padding: 8px 12px;">
            üìê
        </button>
    </div>
    <button id="acceptPolygon" class="btn btn-success w-100 mb-2" style="display: none;">–ì–æ—Ç–æ–≤–æ</button>

    <h4 class="mb-3">–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è</h4>

    <div id="restrictionsList" class="restrictions-list" style="display: none;">
        <h6 class="mb-2">–ù–∞–π–¥–µ–Ω–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:</h6>
        <div id="restrictionsContainer" class="restrictions-container">
            <!-- Restrictions will be inserted here -->
        </div>
    </div>

    <button id="drawZouit" class="btn btn-success w-100 mb-2" style="display: none;">–ó–∞–¥–∞—Ç—å –ó–û–£–ò–¢—ã</button>    
    <button id="acceptZouit" class="btn btn-success w-100 mb-2" style="display: none;">–ì–æ—Ç–æ–≤–æ</button>


    <h4 class="mb-3">–ö–æ–Ω—Ü–µ–ø—Ü–∏—è</h4>
    <div id="buildingParameters" style="display: none;" class="mb-3">
        <div class="mb-2">
            <label for="maxFloors" class="form-label small">–ú–∞–∫—Å. —ç—Ç–∞–∂–Ω–æ—Å—Ç—å:</label>
            <input type="number" id="maxFloors" class="form-control form-control-sm" placeholder="–ë–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π" min="1" max="50">
        </div>
        <div class="mb-2">
            <label for="grossFloorArea" class="form-label small">–û–±—â–∞—è –ø–ª–æ—â–∞–¥—å (–º¬≤):</label>
            <input type="number" id="grossFloorArea" class="form-control form-control-sm" placeholder="–ë–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π" min="1000" step="1000">
        </div>
    </div>
    <button id="generateBuildings" class="btn btn-info w-100 mb-2" style="display: none;">Generate buildings</button>
</div>

<div id="loadingIndicator" class="loading-indicator" style="display: none;">
    <div class="spinner"></div>
    <div class="message">–ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏</div>
</div>

<div id="map"></div>

<!-- Add floating insolation button on map -->
<div id="insolationButton" class="map-control-button" style="display: none;">
    <button id="insolationMode" class="btn btn-warning btn-sm">
        <i class="fas fa-sun"></i> –ò–Ω—Å–æ–ª—è—Ü–∏—è
    </button>
</div>

<!-- Add floating 3D buildings button on map -->
<div id="buildings3DButton" class="map-control-button" style="display: none;">
    <button id="buildings3DMode" class="btn btn-info btn-sm">
        <i class="fas fa-cube"></i> 3D –ó–¥–∞–Ω–∏—è
    </button>
</div>

<!-- Add floating details button on map -->
<div id="detailsButton" class="map-control-button" style="display: none;">
    <button id="showDetails" class="btn btn-secondary btn-sm">
        Details
    </button>
</div>

<div id="buildingsTablePanel" class="buildings-table-panel collapsed">
    <div class="panel-header" id="buildingsTableToggle">
        <h4 class="mb-0">–¢–≠–ü</h4>
        <span class="toggle-icon">‚ñº</span>
    </div>
    <div class="panel-content">
        <div class="table-responsive">
            <table class="table table-striped table-hover table-sm">
                <thead>
                    <tr>
                        <th>‚Ññ</th>
                        <th>–≠—Ç–∞–∂–Ω–æ—Å—Ç—å</th>
                        <th>–ü–ª–æ—â–∞–¥—å –∫–≤–∞—Ä—Ç–∏—Ä, –º¬≤</th>
                        <th>–ö–æ–º–º–µ—Ä—á–µ—Å–∫–∞—è –ø–ª–æ—â–∞–¥—å, –º¬≤</th>
                        <th>–ü–∞—Ä–∫–æ–≤–æ—á–Ω—ã–µ –º–µ—Å—Ç–∞, –º/–º</th>
                        <th>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∂–∏—Ç–µ–ª–µ–π, —á–µ–ª</th>
                        <th>–ú–µ—Å—Ç–∞ –≤ –î–û–£, —á–µ–ª</th>
                        <th>–ú–µ—Å—Ç–∞ –≤ –°–û–£, —á–µ–ª</th>
                    </tr>
                </thead>
                <tbody id="buildingsTableBody">
                </tbody>
            </table>
        </div>
    </div>
</div>

<div id="layoutsPanel" class="layouts-panel">
    <h4 class="mb-3">–ö–æ–Ω—Ü–µ–ø—Ü–∏–∏</h4>
    <div id="layoutsList" class="layouts-list">
        <!-- Layouts will be inserted here -->
    </div>
</div>

<!-- Details Modal -->
<div id="detailsModal" class="modal fade" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-xl" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Generation Details</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div id="detailsContent" class="details-content">
                    <!-- HTML logs will be inserted here -->
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Coordinates Edit Modal -->
<div id="coordinatesModal" class="modal fade" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-lg" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —É—á–∞—Å—Ç–∫–∞</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label for="coordinatesTextarea" class="form-label">–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —É—á–∞—Å—Ç–∫–∞ (—Ñ–æ—Ä–º–∞—Ç: double[][][])</label>
                    <textarea id="coordinatesTextarea" class="form-control" rows="10" placeholder="[[[lng1, lat1], [lng2, lat2], [lng3, lat3], [lng1, lat1]]]"></textarea>
                </div>
                <div class="alert alert-info">
                    <small>
                        <strong>–§–æ—Ä–º–∞—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç:</strong> –ú–∞—Å—Å–∏–≤ –º–∞—Å—Å–∏–≤–æ–≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ [–¥–æ–ª–≥–æ—Ç–∞, —à–∏—Ä–æ—Ç–∞].<br>
                        –ü–æ—Å–ª–µ–¥–Ω—è—è —Ç–æ—á–∫–∞ –¥–æ–ª–∂–Ω–∞ —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å –ø–µ—Ä–≤–æ–π –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–º–∫–Ω—É—Ç–æ–≥–æ –ø–æ–ª–∏–≥–æ–Ω–∞.<br>
                        –ü—Ä–∏–º–µ—Ä: <code>[[[37.123, 55.456], [37.124, 55.456], [37.124, 55.457], [37.123, 55.456]]]</code>
                    </small>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">–û—Ç–º–µ–Ω–∞</button>
                <button type="button" class="btn btn-primary" id="applyCoordinates">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
            </div>
        </div>
    </div>
</div>

<form id="antiForgeryForm" style="display: none;">
    @Html.AntiForgeryToken()
</form>

@section Scripts {
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css' rel='stylesheet' />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet" />
            <script src="~/js/3d-buildings.js?v=12"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        .sidebar {
            position: fixed;
            left: 0;
            top: 56px;
            bottom: 0;
            width: 250px;
            background: #f8f9fa;
            padding: 20px;
            border-right: 1px solid #dee2e6;
            z-index: 1000;
        }

        #map {
            position: fixed;
            left: 250px;
            right: 300px;
            top: 56px;
            bottom: 40px; /* Adjusted for collapsed panel */
        }

        .buildings-table-panel {
            position: fixed;
            left: 250px;
            right: 300px;
            bottom: 0;
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .buildings-table-panel.collapsed {
            height: 40px;
        }

        .buildings-table-panel:not(.collapsed) {
            height: 300px;
        }

        .buildings-table-panel .panel-header {
            padding: 8px 20px;
            background: #f8f9fa;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #dee2e6;
        }

        .buildings-table-panel .panel-header:hover {
            background: #e9ecef;
        }

        .buildings-table-panel .panel-header h4 {
            font-size: 0.9rem;
            margin: 0;
        }

        .buildings-table-panel .panel-header .toggle-icon {
            font-size: 0.8rem;
        }

        .buildings-table-panel .panel-content {
            padding: 15px;
            overflow-y: auto;
            height: calc(100% - 40px);
        }

        .buildings-table-panel.collapsed .panel-content {
            display: none;
        }

        .buildings-table-panel .toggle-icon {
            transition: transform 0.3s ease;
        }

        .buildings-table-panel.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        .table-sm td, .table-sm th {
            padding: 0.25rem;
            font-size: 0.7rem;
            text-align: right;
        }

        .table-sm th:first-child,
        .table-sm td:first-child {
            text-align: left;
        }

        .layouts-panel {
            position: fixed;
            right: 0;
            top: 56px;
            bottom: 0;
            width: 300px;
            background: #f8f9fa;
            padding: 20px;
            border-left: 1px solid #dee2e6;
            z-index: 1000;
            overflow-y: auto;
        }

        .layout-card {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .layout-card:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .layout-card.active {
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }

        .layout-card h5 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #333;
        }

        .layout-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 14px;
        }

        .metric-item {
            display: flex;
            flex-direction: column;
        }

        .metric-label {
            color: #666;
            font-size: 12px;
        }

        .metric-value {
            font-weight: 500;
            color: #333;
        }

        .mapboxgl-ctrl-3d {
            background-image: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23333"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>');
            background-size: 20px;
            background-position: center;
            background-repeat: no-repeat;
            width: 30px;
            height: 30px;
            cursor: pointer;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.1);
        }

        .mapboxgl-ctrl-3d.active {
            background-color: #e0e0e0;
        }

        .mapboxgl-ctrl-group {
            margin: 10px !important;
        }

        .drawing-cursor {
            cursor: crosshair !important;
        }

        .point-marker {
            width: 8px;
            height: 8px;
            background-color: #ff0000;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.2);
        }

        .loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            text-align: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            margin: 0 auto 10px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .message {
            color: #333;
            font-size: 16px;
            font-weight: 500;
        }

        .restrictions-list {
            margin-top: 15px;
            padding: 10px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            max-height: 200px;
            overflow-y: auto;
        }

        .restrictions-container {
            font-size: 0.85rem;
        }

        .restriction-item {
            padding: 5px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .restriction-item:last-child {
            border-bottom: none;
        }

        .restriction-type {
            font-weight: 600;
            color: #495057;
        }

        .restriction-name {
            color: #6c757d;
            font-size: 0.8rem;
        }

        .restriction-detail {
            color: #495057;
            font-size: 0.75rem;
            margin-left: 10px;
            margin-top: 2px;
            font-style: italic;
        }

        .map-control-button {
            position: fixed;
            z-index: 1001;
            border-radius: 4px;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.1);
            padding: 5px;
        }

        #insolationButton {
            top: 66px;
            left: 260px;
            background: white;
        }

        #buildings3DButton {
            top: 66px;
            left: 370px;
            background: white;
        }

        #detailsButton {
            bottom: 60px;
            right: 320px;
            background: white;
        }

        .map-control-button button {
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            height: 32px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #insolationButton button {
            background: #ffc107;
            color: #212529;
        }

        #insolationButton button:hover {
            background: #e0a800;
            transform: translateY(-1px);
        }

        #insolationButton button.active {
            background: #28a745;
            color: white;
        }

        #buildings3DButton button {
            background: #17a2b8;
            color: white;
        }

        #buildings3DButton button:hover {
            background: #138496;
            transform: translateY(-1px);
        }

        #buildings3DButton button.active {
            background: #28a745;
            color: white;
        }

        #detailsButton button {
            background: #6c757d;
            color: white;
        }

        #detailsButton button:hover {
            background: #5a6268;
            color: white;
            transform: translateY(-1px);
        }

        /* Details Modal Styles */
        .modal-xl {
            max-width: 90%;
        }

        .details-content {
            max-height: 70vh;
            overflow-y: auto;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .details-content div {
            margin-bottom: 8px;
            padding: 5px;
            background: white;
            border-radius: 4px;
            border-left: 3px solid #007bff;
        }

        .details-content svg {
            max-width: 100%;
            height: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            margin: 5px 0;
        }

        /* Success alert styles */
        .alert-success {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }

        /* Coordinates edit button styles */
        #editCoordinates {
            font-size: 16px;
            padding: 8px 12px;
            border: 1px solid #6c757d;
            background-color: #fff;
            color: #6c757d;
        }

        #editCoordinates:hover {
            background-color: #6c757d;
            color: #fff;
        }
    </style>
    <script>
        const mapboxToken = '@Model.Configuration["Mapbox:AccessToken"]';
        if (!mapboxToken || mapboxToken === 'YOUR_MAPBOX_ACCESS_TOKEN') {
            showError('Mapbox access token is not configured. Please add your Mapbox access token to appsettings.json');
        } else {
            // Initialize the map
            mapboxgl.accessToken = mapboxToken;
            const map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/streets-v11',
                center: [60.6057, 56.8389], // Ekaterinburg coordinates
                zoom: 13,
                pitch: 0, // Start in 2D mode
                bearing: 0,
                antialias: true
            });

            // Add navigation controls
            map.addControl(new mapboxgl.NavigationControl(), 'top-right');

            // Custom 3D toggle control
            class Toggle3DControl {
                constructor() {
                    this._map = null;
                    this._container = null;
                    this._is3D = false;
                }

                onAdd(map) {
                    this._map = map;
                    this._container = document.createElement('div');
                    this._container.className = 'mapboxgl-ctrl mapboxgl-ctrl-group';
                    this._button = document.createElement('button');
                    this._button.className = 'mapboxgl-ctrl-3d';
                    this._button.type = 'button';
                    this._button.title = 'Toggle 3D View';
                    this._button.onclick = () => this._toggle3D();
                    this._container.appendChild(this._button);
                    return this._container;
                }

                onRemove() {
                    this._container.parentNode.removeChild(this._container);
                    this._map = null;
                }

                _toggle3D() {
                    this._is3D = !this._is3D;
                    this._button.classList.toggle('active', this._is3D);
                    
                    const targetPitch = this._is3D ? 45 : 0;
                    const targetBearing = this._is3D ? -17.6 : 0;
                    
                    map.easeTo({
                        pitch: targetPitch,
                        bearing: targetBearing,
                        duration: 1000
                    });
                }
            }

            // Add 3D toggle control
            map.addControl(new Toggle3DControl(), 'top-right');

            // Add 3D building layer
            map.on('load', () => {
                map.addLayer({
                    'id': '3d-buildings',
                    'source': 'composite',
                    'source-layer': 'building',
                    'filter': ['==', 'extrude', 'true'],
                    'type': 'fill-extrusion',
                    'minzoom': 15,
                    'paint': {
                        'fill-extrusion-color': '#aaa',
                        'fill-extrusion-height': ['get', 'height'],
                        'fill-extrusion-base': ['get', 'min_height'],
                        'fill-extrusion-opacity': 0.6
                    }
                });
                
                // Initialize 3D building generator
                building3DGenerator = new Building3DGenerator();
                window.map = map; // Make map globally available for 3D generator
            });

            let polygonPoints = [];
            let isDrawingPolygon = false;
            let tempPolygon = null;
            let finalPolygon = null;
            let generatedBuildings = [];
            let pointMarkers = [];
            let previewLine = null;

            let zouitPoints = [];
            let isDrawingZouit = false;
            let tempZouit = null;
            let finalZouit = null;
            let zouitMarkers = [];
            let zouitPreviewLine = null;

            let insolationMode = false;
            let sectionExtrusions = [];
            let generatedParks = [];
            let currentLayouts = null;
            let currentLogs = null;
            
            // Initialize 3D building generator
            let building3DGenerator = null;
            let buildings3DMode = false;

            function showError(message) {
                const errorDiv = document.getElementById('errorMessage');
                errorDiv.innerHTML = message.replace(/\n/g, '<br>');
                errorDiv.style.display = 'block';
                
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 10000);
            }

            function showSuccess(message) {
                const errorDiv = document.getElementById('errorMessage');
                errorDiv.innerHTML = message.replace(/\n/g, '<br>');
                errorDiv.style.display = 'block';
                errorDiv.className = 'alert alert-success';
                
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                    errorDiv.className = 'alert alert-danger';
                }, 5000);
            }

            // Polygon drawing functionality
            document.getElementById('drawPolygon').addEventListener('click', function() {
                if (!isDrawingPolygon) {
                    startDrawingPolygon();
                } else {
                    cancelDrawingPolygon();
                }
            });

            // Coordinates editing functionality
            document.addEventListener('DOMContentLoaded', function() {
                const editButton = document.getElementById('editCoordinates');
                if (editButton) {
                    console.log('Edit coordinates button found');
                    editButton.addEventListener('click', function() {
                        console.log('Edit coordinates button clicked');
                        openCoordinatesModal();
                    });
                } else {
                    console.error('Edit coordinates button not found');
                }
            });

            document.getElementById('applyCoordinates').addEventListener('click', function() {
                applyCoordinatesFromModal();
            });

            document.getElementById('acceptPolygon').addEventListener('click', async function() {
                if (polygonPoints.length >= 3) {
                    if (finalPolygon) {
                        map.removeLayer(finalPolygon);
                        map.removeSource(finalPolygon);
                    }
                    // Create a closed polygon by adding the first point at the end
                    const closedPoints = [...polygonPoints, polygonPoints[0]];
                    const polygonId = 'final-polygon';
                    
                    map.addSource(polygonId, {
                        'type': 'geojson',
                        'data': {
                            'type': 'Feature',
                            'properties': {},
                            'geometry': {
                                'type': 'Polygon',
                                'coordinates': [closedPoints.map(p => [p.lng, p.lat])]
                            }
                        }
                    });

                    map.addLayer({
                        'id': polygonId,
                        'type': 'fill',
                        'source': polygonId,
                        'layout': {},
                        'paint': {
                            'fill-color': '#a6c9ed',
                            'fill-opacity': 0.5
                        }
                    });

                    finalPolygon = polygonId;
                    document.getElementById('acceptPolygon').style.display = 'none';
                    document.getElementById('drawPolygon').textContent = '–ó–∞–¥–∞—Ç—å —É—á–∞—Å—Ç–æ–∫';
                    document.getElementById('drawPolygon').classList.remove('btn-danger');
                    document.getElementById('drawPolygon').classList.add('btn-primary');
                    document.getElementById('generateBuildings').style.display = 'block';
                    document.getElementById('buildingParameters').style.display = 'block';
                    isDrawingPolygon = false;
                    map.getCanvas().classList.remove('drawing-cursor');

                    // Clear point markers
                    pointMarkers.forEach(marker => marker.remove());
                    pointMarkers = [];
                    
                    // Clear preview line
                    if (previewLine) {
                        map.removeLayer(previewLine);
                        map.removeSource(previewLine);
                        previewLine = null;
                    }

                    // Get and draw restrictions for the polygon
                    const restrictions = await getRestrictionsForPolygon(polygonPoints);
                    drawRestrictions(restrictions);
                }
            });

            function startDrawingPolygon() {
                isDrawingPolygon = true;
                polygonPoints = [];
                if (finalPolygon) {
                    map.removeLayer(finalPolygon);
                    map.removeSource(finalPolygon);
                    finalPolygon = null;
                }
                // Clear generated buildings
                generatedBuildings.forEach(building => {
                    map.removeLayer(building);
                    map.removeSource(building);
                });
                generatedBuildings = [];
                
                document.getElementById('drawPolygon').textContent = '–û—Ç–º–µ–Ω–∏—Ç—å';
                document.getElementById('drawPolygon').classList.remove('btn-primary');
                document.getElementById('drawPolygon').classList.add('btn-danger');
                document.getElementById('acceptPolygon').style.display = 'none';
                document.getElementById('generateBuildings').style.display = 'none';
                document.getElementById('buildingParameters').style.display = 'none';
                document.getElementById('insolationButton').style.display = 'none';
                document.getElementById('buildings3DButton').style.display = 'none';
                document.getElementById('detailsButton').style.display = 'none';
                map.getCanvas().classList.add('drawing-cursor');
            }

            function cancelDrawingPolygon() {
                isDrawingPolygon = false;
                polygonPoints = [];
                if (tempPolygon) {
                    map.removeLayer(tempPolygon);
                    map.removeSource(tempPolygon);
                    tempPolygon = null;
                }
                if (finalPolygon) {
                    map.removeLayer(finalPolygon);
                    map.removeSource(finalPolygon);
                    finalPolygon = null;
                }
                // Clear generated buildings
                generatedBuildings.forEach(building => {
                    map.removeLayer(building);
                    map.removeSource(building);
                });
                generatedBuildings = [];
                
                // Clear point markers
                pointMarkers.forEach(marker => marker.remove());
                pointMarkers = [];
                
                // Clear preview line
                if (previewLine) {
                    map.removeLayer(previewLine);
                    map.removeSource(previewLine);
                    previewLine = null;
                }
                
                document.getElementById('drawPolygon').textContent = '–ó–∞–¥–∞—Ç—å —É—á–∞—Å—Ç–æ–∫';
                document.getElementById('drawPolygon').classList.remove('btn-danger');
                document.getElementById('drawPolygon').classList.add('btn-primary');
                document.getElementById('acceptPolygon').style.display = 'none';
                document.getElementById('generateBuildings').style.display = 'none';
                document.getElementById('buildingParameters').style.display = 'none';
                document.getElementById('insolationButton').style.display = 'none';
                document.getElementById('buildings3DButton').style.display = 'none';
                document.getElementById('detailsButton').style.display = 'none';
                map.getCanvas().classList.remove('drawing-cursor');
            }

            function openCoordinatesModal() {
                const textarea = document.getElementById('coordinatesTextarea');
                
                // If there are existing polygon points, convert them to the expected format
                if (polygonPoints.length > 0) {
                    const coordinates = polygonPoints.map(p => [p.lng, p.lat]);
                    // Add the first point at the end to close the polygon
                    coordinates.push([polygonPoints[0].lng, polygonPoints[0].lat]);
                    textarea.value = JSON.stringify([coordinates], null, 2);
                } else {
                    textarea.value = '';
                }
                
                const modal = new bootstrap.Modal(document.getElementById('coordinatesModal'));
                modal.show();
            }

            function applyCoordinatesFromModal() {
                const textarea = document.getElementById('coordinatesTextarea');
                const coordinatesText = textarea.value.trim();
                
                if (!coordinatesText) {
                    showError('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã');
                    return;
                }
                
                try {
                    const coordinates = JSON.parse(coordinatesText);
                    
                    // Validate the format
                    if (!Array.isArray(coordinates) || coordinates.length === 0) {
                        throw new Error('–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º');
                    }
                    
                    const polygonCoords = coordinates[0];
                    if (!Array.isArray(polygonCoords) || polygonCoords.length < 3) {
                        throw new Error('–ü–æ–ª–∏–≥–æ–Ω –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 3 —Ç–æ—á–∫–∏');
                    }
                    
                    // Convert coordinates to polygonPoints format
                    const newPolygonPoints = polygonCoords.map(coord => ({
                        lng: coord[0],
                        lat: coord[1]
                    }));
                    
                    // Remove the last point if it's the same as the first (closing point)
                    if (newPolygonPoints.length > 3 && 
                        newPolygonPoints[0].lng === newPolygonPoints[newPolygonPoints.length - 1].lng &&
                        newPolygonPoints[0].lat === newPolygonPoints[newPolygonPoints.length - 1].lat) {
                        newPolygonPoints.pop();
                    }
                    
                    // Apply the new coordinates
                    polygonPoints = newPolygonPoints;
                    
                    // Clear existing polygon
                    if (finalPolygon) {
                        map.removeLayer(finalPolygon);
                        map.removeSource(finalPolygon);
                        finalPolygon = null;
                    }
                    
                    // Clear point markers
                    pointMarkers.forEach(marker => marker.remove());
                    pointMarkers = [];
                    
                    // Create new polygon
                    if (polygonPoints.length >= 3) {
                        const closedPoints = [...polygonPoints, polygonPoints[0]];
                        const polygonId = 'final-polygon';
                        
                        map.addSource(polygonId, {
                            'type': 'geojson',
                            'data': {
                                'type': 'Feature',
                                'properties': {},
                                'geometry': {
                                    'type': 'Polygon',
                                    'coordinates': [closedPoints.map(p => [p.lng, p.lat])]
                                }
                            }
                        });

                        map.addLayer({
                            'id': polygonId,
                            'type': 'fill',
                            'source': polygonId,
                            'layout': {},
                            'paint': {
                                'fill-color': '#a6c9ed',
                                'fill-opacity': 0.5
                            }
                        });

                        finalPolygon = polygonId;
                        document.getElementById('generateBuildings').style.display = 'block';
                    document.getElementById('buildingParameters').style.display = 'block';
                        
                        // Center map on the new polygon
                        centerMapOnPolygon(polygonPoints);
                        
                        // Get and draw restrictions for the polygon
                        getRestrictionsForPolygon(polygonPoints).then(restrictions => {
                            drawRestrictions(restrictions);
                        });
                    }
                    
                    // Close the modal
                    const modal = bootstrap.Modal.getInstance(document.getElementById('coordinatesModal'));
                    modal.hide();
                    
                    showSuccess('–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —É—á–∞—Å—Ç–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω—ã');
                    
                } catch (error) {
                    showError('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç: ' + error.message);
                }
            }

            function centerMapOnPolygon(points) {
                if (!points || points.length === 0) return;
                
                // Calculate bounds of the polygon
                let minLng = points[0].lng;
                let maxLng = points[0].lng;
                let minLat = points[0].lat;
                let maxLat = points[0].lat;
                
                points.forEach(point => {
                    minLng = Math.min(minLng, point.lng);
                    maxLng = Math.max(maxLng, point.lng);
                    minLat = Math.min(minLat, point.lat);
                    maxLat = Math.max(maxLat, point.lat);
                });
                
                // Add some padding around the polygon
                const padding = 0.001; // Adjust this value for more or less padding
                const bounds = [
                    [minLng - padding, minLat - padding],
                    [maxLng + padding, maxLat + padding]
                ];
                
                // Fit the map to the bounds with animation
                map.fitBounds(bounds, {
                    padding: 50, // Additional padding in pixels
                    duration: 1000, // Animation duration in milliseconds
                    essential: true
                });
            }

            function updatePreviewLine(currentPoint) {
                if (polygonPoints.length === 0) return;

                if (previewLine) {
                    map.removeLayer(previewLine);
                    map.removeSource(previewLine);
                }

                const previewLineId = 'preview-line';
                map.addSource(previewLineId, {
                    'type': 'geojson',
                    'data': {
                        'type': 'Feature',
                        'properties': {},
                        'geometry': {
                            'type': 'LineString',
                            'coordinates': [
                                [polygonPoints[polygonPoints.length - 1].lng, polygonPoints[polygonPoints.length - 1].lat],
                                [currentPoint.lng, currentPoint.lat]
                            ]
                        }
                    }
                });

                map.addLayer({
                    'id': previewLineId,
                    'type': 'line',
                    'source': previewLineId,
                    'layout': {},
                    'paint': {
                        'line-color': '#0000ff',
                        'line-width': 2,
                        'line-dasharray': [2, 2]
                    }
                });

                previewLine = previewLineId;
            }

            // ZOUIT drawing functionality
            document.getElementById('drawZouit').addEventListener('click', function() {
                if (!isDrawingZouit) {
                    startDrawingZouit();
                } else {
                    cancelDrawingZouit();
                }
            });

            document.getElementById('acceptZouit').addEventListener('click', function() {
                if (zouitPoints.length >= 3) {
                    if (finalZouit) {
                        map.removeLayer(finalZouit);
                        map.removeSource(finalZouit);
                    }
                    // Create a closed polygon by adding the first point at the end
                    const closedPoints = [...zouitPoints, zouitPoints[0]];
                    const zouitId = 'final-zouit';
                    
                    map.addSource(zouitId, {
                        'type': 'geojson',
                        'data': {
                            'type': 'Feature',
                            'properties': {},
                            'geometry': {
                                'type': 'Polygon',
                                'coordinates': [closedPoints.map(p => [p.lng, p.lat])]
                            }
                        }
                    });

                    map.addLayer({
                        'id': zouitId,
                        'type': 'fill',
                        'source': zouitId,
                        'layout': {},
                        'paint': {
                            'fill-color': '#00ff00',
                            'fill-opacity': 0.3
                        }
                    });

                    finalZouit = zouitId;
                    document.getElementById('acceptZouit').style.display = 'none';
                    document.getElementById('drawZouit').textContent = '–ó–∞–¥–∞—Ç—å –ó–û–£–ò–¢—ã';
                    document.getElementById('drawZouit').classList.remove('btn-danger');
                    document.getElementById('drawZouit').classList.add('btn-success');
                    isDrawingZouit = false;
                    map.getCanvas().classList.remove('drawing-cursor');

                    // Clear point markers
                    zouitMarkers.forEach(marker => marker.remove());
                    zouitMarkers = [];
                    
                    // Clear preview line
                    if (zouitPreviewLine) {
                        map.removeLayer(zouitPreviewLine);
                        map.removeSource(zouitPreviewLine);
                        zouitPreviewLine = null;
                    }
                }
            });

            function startDrawingZouit() {
                isDrawingZouit = true;
                zouitPoints = [];
                if (finalZouit) {
                    map.removeLayer(finalZouit);
                    map.removeSource(finalZouit);
                    finalZouit = null;
                }
                
                document.getElementById('drawZouit').textContent = '–û—Ç–º–µ–Ω–∏—Ç—å';
                document.getElementById('drawZouit').classList.remove('btn-success');
                document.getElementById('drawZouit').classList.add('btn-danger');
                document.getElementById('acceptZouit').style.display = 'none';
                map.getCanvas().classList.add('drawing-cursor');
            }

            function cancelDrawingZouit() {
                isDrawingZouit = false;
                zouitPoints = [];
                if (tempZouit) {
                    map.removeLayer(tempZouit);
                    map.removeSource(tempZouit);
                    tempZouit = null;
                }
                if (finalZouit) {
                    map.removeLayer(finalZouit);
                    map.removeSource(finalZouit);
                    finalZouit = null;
                }
                
                // Clear point markers
                zouitMarkers.forEach(marker => marker.remove());
                zouitMarkers = [];
                
                // Clear preview line
                if (zouitPreviewLine) {
                    map.removeLayer(zouitPreviewLine);
                    map.removeSource(zouitPreviewLine);
                    zouitPreviewLine = null;
                }
                
                document.getElementById('drawZouit').textContent = '–ó–∞–¥–∞—Ç—å –ó–û–£–ò–¢—ã';
                document.getElementById('drawZouit').classList.remove('btn-danger');
                document.getElementById('drawZouit').classList.add('btn-success');
                document.getElementById('acceptZouit').style.display = 'none';
                map.getCanvas().classList.remove('drawing-cursor');
            }

            function updateZouitPreviewLine(currentPoint) {
                if (zouitPoints.length === 0) return;

                if (zouitPreviewLine) {
                    map.removeLayer(zouitPreviewLine);
                    map.removeSource(zouitPreviewLine);
                }

                const previewLineId = 'preview-zouit-line';
                map.addSource(previewLineId, {
                    'type': 'geojson',
                    'data': {
                        'type': 'Feature',
                        'properties': {},
                        'geometry': {
                            'type': 'LineString',
                            'coordinates': [
                                [zouitPoints[zouitPoints.length - 1].lng, zouitPoints[zouitPoints.length - 1].lat],
                                [currentPoint.lng, currentPoint.lat]
                            ]
                        }
                    }
                });

                map.addLayer({
                    'id': previewLineId,
                    'type': 'line',
                    'source': previewLineId,
                    'layout': {},
                    'paint': {
                        'line-color': '#00ff00',
                        'line-width': 2,
                        'line-dasharray': [2, 2]
                    }
                });

                zouitPreviewLine = previewLineId;
            }

            // Modify the existing click handler to handle both polygon and ZOUIT drawing
            map.on('click', function(e) {
                if (isDrawingPolygon) {
                    const point = e.lngLat;
                    polygonPoints.push(point);

                    // Add point marker
                    const marker = document.createElement('div');
                    marker.className = 'point-marker';
                    new mapboxgl.Marker(marker)
                        .setLngLat([point.lng, point.lat])
                        .addTo(map);
                    pointMarkers.push(marker);

                    // Update temporary polygon
                    if (tempPolygon) {
                        map.removeLayer(tempPolygon);
                        map.removeSource(tempPolygon);
                    }
                    if (polygonPoints.length >= 2) {
                        const tempPolygonId = 'temp-polygon';
                        map.addSource(tempPolygonId, {
                            'type': 'geojson',
                            'data': {
                                'type': 'Feature',
                                'properties': {},
                                'geometry': {
                                    'type': 'Polygon',
                                    'coordinates': [polygonPoints.map(p => [p.lng, p.lat])]
                                }
                            }
                        });

                        map.addLayer({
                            'id': tempPolygonId,
                            'type': 'fill',
                            'source': tempPolygonId,
                            'layout': {},
                            'paint': {
                                'fill-color': '#0000ff',
                                'fill-opacity': 0.3
                            }
                        });

                        tempPolygon = tempPolygonId;
                    }

                    // Show accept button when we have 3 or more points
                    if (polygonPoints.length >= 3) {
                        document.getElementById('acceptPolygon').style.display = 'block';
                    }
                } else if (isDrawingZouit) {
                    const point = e.lngLat;
                    zouitPoints.push(point);

                    // Add point marker
                    const marker = document.createElement('div');
                    marker.className = 'point-marker';
                    new mapboxgl.Marker(marker)
                        .setLngLat([point.lng, point.lat])
                        .addTo(map);
                    zouitMarkers.push(marker);

                    // Update temporary ZOUIT
                    if (tempZouit) {
                        map.removeLayer(tempZouit);
                        map.removeSource(tempZouit);
                    }
                    if (zouitPoints.length >= 2) {
                        const tempZouitId = 'temp-zouit';
                        map.addSource(tempZouitId, {
                            'type': 'geojson',
                            'data': {
                                'type': 'Feature',
                                'properties': {},
                                'geometry': {
                                    'type': 'Polygon',
                                    'coordinates': [zouitPoints.map(p => [p.lng, p.lat])]
                                }
                            }
                        });

                        map.addLayer({
                            'id': tempZouitId,
                            'type': 'fill',
                            'source': tempZouitId,
                            'layout': {},
                            'paint': {
                                'fill-color': '#00ff00',
                                'fill-opacity': 0.3
                            }
                        });

                        tempZouit = tempZouitId;
                    }

                    // Show accept button when we have 3 or more points
                    if (zouitPoints.length >= 3) {
                        document.getElementById('acceptZouit').style.display = 'block';
                    }
                }
            });

            // Modify the existing mousemove handler to handle both polygon and ZOUIT drawing
            map.on('mousemove', function(e) {
                if (isDrawingPolygon && polygonPoints.length > 0) {
                    updatePreviewLine(e.lngLat);
                } else if (isDrawingZouit && zouitPoints.length > 0) {
                    updateZouitPreviewLine(e.lngLat);
                }
            });

            document.getElementById('generateBuildings').addEventListener('click', async function() {
                if (!finalPolygon) return;

                // Show loading indicator
                document.getElementById('loadingIndicator').style.display = 'block';

                // Clear previous buildings
                generatedBuildings.forEach(building => {
                    map.removeLayer(building);
                    map.removeSource(building);
                });
                generatedBuildings = [];
                // Clear previous section extrusions
                sectionExtrusions.forEach(id => {
                    if (map.getLayer(id)) map.removeLayer(id);
                    if (map.getSource(id)) map.removeSource(id);
                });
                sectionExtrusions = [];
                insolationMode = false;
                document.getElementById('insolationMode').textContent = '–ò–Ω—Å–æ–ª—è—Ü–∏—è';
                document.getElementById('insolationMode').classList.remove('active');
                document.getElementById('insolationButton').style.display = 'none';
                document.getElementById('detailsButton').style.display = 'none';

                try {
                    // Use the OnPostGenerateBuildings method instead of API
                    const response = await fetch('?handler=GenerateBuildings', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        },
                        body: JSON.stringify({
                            PolygonPoints: polygonPoints,
                            MaxFloors: document.getElementById('maxFloors').value ? parseInt(document.getElementById('maxFloors').value) : null,
                            GrossFloorArea: document.getElementById('grossFloorArea').value ? parseFloat(document.getElementById('grossFloorArea').value) : null
                        }),
                        signal: AbortSignal.timeout(300000) // 5 minutes timeout
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        let errorMessage = errorData.error || 'Failed to generate buildings';
                        if (errorData.details) {
                            console.error('Error details:', errorData.details);
                        }
                        
                        // Store logs from error response if available
                        if (errorData.logs) {
                            currentLogs = errorData.logs;
                            // Show details button so user can see what went wrong
                            document.getElementById('detailsButton').style.display = 'block';
                        }
                        
                        throw new Error(errorMessage);
                    }

                    const buildings = await response.json();
                    currentLayouts = buildings.layouts;
                    currentLogs = buildings.logs || '';
                    console.log('Received buildings:', buildings);
                    
                    if (!buildings || !buildings.layouts || !buildings.layouts.length) {
                        console.error('Invalid buildings data:', buildings);
                        throw new Error('Invalid response format: missing layouts data');
                    }

                    // Update layouts panel
                    const layoutsList = document.getElementById('layoutsList');
                    layoutsList.innerHTML = ''; // Clear existing layouts

                    buildings.layouts.forEach((layout, index) => {
                        const layoutCard = document.createElement('div');
                        layoutCard.className = 'layout-card';
                        if (index === 0) layoutCard.classList.add('active');
                        
                        layoutCard.innerHTML = `
                            <h5>${layout.name}</h5>
                                                        <div class="layout-metrics">
                                <div class="metric-item">
                                    <span class="metric-label">–ü–æ–ª–µ–∑–Ω–∞—è –ø–ª–æ—â–∞–¥—å</span>
                                    <span class="metric-value">${Math.round(layout.usefulArea)} –º¬≤</span>
                                </div>
                                <div class="metric-item">
                                    <span class="metric-label">–ò–Ω—Å–æ–ª—è—Ü–∏—è</span>
                                    <span class="metric-value">${(layout.insolation * 100).toFixed(1)}%</span>
                                </div>
                                <div class="metric-item">
                                    <span class="metric-label">–°—Ç–æ–∏–º–æ—Å—Ç—å</span>
                                    <span class="metric-value">${Math.round(layout.cost)} ‚ÇΩ</span>
                                </div>
                                <div class="metric-item">
                                    <span class="metric-label">–û—Ü–µ–Ω–∫–∞</span>
                                    <span class="metric-value">${Math.round(layout.value)}</span>
                                </div>
                            </div>
                        `;
                        
                        layoutCard.addEventListener('click', async function() {
                            // Remove active class from all cards
                            document.querySelectorAll('.layout-card').forEach(card => card.classList.remove('active'));
                            // Add active class to clicked card
                            this.classList.add('active');
                            // Display the selected layout
                            await displayLayout(layout, false);
                        });
                        
                        layoutsList.appendChild(layoutCard);
                    });

                    // Display the first layout
                    await displayLayout(buildings.layouts[0], true);
                    
                    // Show insolation button, 3D buildings button, and details button
                    document.getElementById('insolationButton').style.display = 'block';
                    document.getElementById('buildings3DButton').style.display = 'block'; // Hidden for now
                    document.getElementById('detailsButton').style.display = 'block';

                    async function displayLayout(layout, changeCamera) {
                        // Store current insolation mode state
                        const wasInInsolationMode = insolationMode;
                        
                        // Clear previous buildings
                        generatedBuildings.forEach(building => {
                            map.removeLayer(building);
                            map.removeSource(building);
                        });
                        generatedBuildings = [];
                        // Clear previous section extrusions
                        sectionExtrusions.forEach(id => {
                            if (map.getLayer(id)) map.removeLayer(id);
                            if (map.getSource(id)) map.removeSource(id);
                        });
                        sectionExtrusions = [];
                        // Clear previous parks
                        generatedParks.forEach(parkId => {
                            if (map.getLayer(parkId)) map.removeLayer(parkId);
                            if (map.getSource(parkId)) map.removeSource(parkId);
                        });
                        generatedParks = [];
                        
                        // Reset insolation mode state but preserve the button state
                        insolationMode = false;
                        if (!wasInInsolationMode) {
                            document.getElementById('insolationMode').textContent = '–ò–Ω—Å–æ–ª—è—Ü–∏—è';
                            document.getElementById('insolationMode').classList.remove('active');
                        }

                        // Show buildings table panel (but keep it collapsed)
                        document.getElementById('buildingsTablePanel').style.display = 'block';

                        // Update buildings table
                        const tableBody = document.getElementById('buildingsTableBody');
                        tableBody.innerHTML = '';
                        
                        let totalApartmentsArea = 0;
                        let totalCommercialArea = 0;
                        let totalParkingPlaces = 0;
                        let totalResidents = 0;
                        let totalKindergardenPlaces = 0;
                        let totalSchoolPlaces = 0;

                        layout.sections.forEach((section, index) => {
                            const row = document.createElement('tr');
                            row.innerHTML = `
                                <td>${index + 1}</td>
                                <td>${section.floors}</td>
                                <td>${Math.round(section.appartmetsArea)}</td>
                                <td>${Math.round(section.commercialArea)}</td>
                                <td>${section.parkingPlaces}</td>
                                <td>${section.residents}</td>
                                <td>${section.kindergardenPlaces}</td>
                                <td>${section.schoolPlaces}</td>
                            `;
                            tableBody.appendChild(row);
                            
                            totalApartmentsArea += section.appartmetsArea;
                            totalCommercialArea += section.commercialArea;
                            totalParkingPlaces += section.parkingPlaces;
                            totalResidents += section.residents;
                            totalKindergardenPlaces += section.kindergardenPlaces;
                            totalSchoolPlaces += section.schoolPlaces;
                        });

                        // Add total row
                        const totalRow = document.createElement('tr');
                        totalRow.className = 'table-secondary';
                        totalRow.innerHTML = `
                            <td><strong>–ò—Ç–æ–≥–æ</strong></td>
                            <td>-</td>
                            <td><strong>${Math.round(totalApartmentsArea)}</strong></td>
                            <td><strong>${Math.round(totalCommercialArea)}</strong></td>
                            <td><strong>${totalParkingPlaces}</strong></td>
                            <td><strong>${totalResidents}</strong></td>
                            <td><strong>${totalKindergardenPlaces}</strong></td>
                            <td><strong>${totalSchoolPlaces}</strong></td>
                        `;
                        tableBody.appendChild(totalRow);

                        // Draw buildings on the map
                        layout.sections.forEach((section, index) => {
                            const buildingId = `building-${index}`;
                            const height = section.height || (section.floors * 3.2);
                            
                            // Server now sends double[][][] format directly - no need to access .coordinates[0]
                            const coordinates = section.polygon[0]; // First ring (exterior) of the polygon
                            
                            map.addSource(buildingId, {
                                'type': 'geojson',
                                'data': {
                                    'type': 'Feature',
                                    'properties': {
                                        'height': height
                                    },
                                    'geometry': {
                                        'type': 'Polygon',
                                        'coordinates': [coordinates]
                                    }
                                }
                            });

                            map.addLayer({
                                'id': buildingId,
                                'type': 'fill-extrusion',
                                'source': buildingId,
                                'paint': {
                                    'fill-extrusion-color': '#666',
                                    'fill-extrusion-height': height,
                                    'fill-extrusion-base': 0,
                                    'fill-extrusion-opacity': 0.7
                                }
                            });
                            
                            generatedBuildings.push(buildingId);
                        });

                        // Draw parks on the map
                        console.log('Layout parks data:', layout.parks);
                        if (layout.parks && layout.parks.length > 0) {
                            console.log('Drawing', layout.parks.length, 'parks');
                            layout.parks.forEach((park, index) => {
                                const parkId = `park-${index}`;
                                console.log(`Processing park ${index}:`, park);
                                
                                // Park coordinates are in the format double[][][]
                                const coordinates = park[0]; // First ring (exterior) of the polygon
                                console.log(`Park ${index} coordinates:`, coordinates);
                                
                                map.addSource(parkId, {
                                    'type': 'geojson',
                                    'data': {
                                        'type': 'Feature',
                                        'properties': {
                                            'type': 'park'
                                        },
                                        'geometry': {
                                            'type': 'Polygon',
                                            'coordinates': [coordinates]
                                        }
                                    }
                                });

                                map.addLayer({
                                    'id': parkId,
                                    'type': 'fill',
                                    'source': parkId,
                                    'paint': {
                                        'fill-color': '#00aa00',
                                        'fill-opacity': 0.6,
                                        'fill-outline-color': '#008800'
                                    }
                                });
                                
                                console.log(`Added park layer: ${parkId}`);
                                generatedParks.push(parkId);
                            });
                            console.log('Total parks added:', generatedParks.length);
                        } else {
                            console.log('No parks to display');
                        }

                        // If we were in insolation mode, switch to it now
                        if (wasInInsolationMode) {
                            // Hide buildings
                            generatedBuildings.forEach(id => {
                                if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', 'none');
                            });
                            // Draw bay extrusions
                            const layout = currentLayouts.find((l, idx) => document.querySelectorAll('.layout-card')[idx].classList.contains('active')) || currentLayouts[0];
                            layout.sections.forEach((section, i) => {
                                section.bays.forEach((bay, j) => {
                                    // Red part: from 0 up to min(shadowHeight, house.height)
                                    const redHeight = Math.min(bay.shadowHeight, section.height);
                                    if (redHeight > 0) {
                                        const redId = `bay-red-${i}-${j}`;
                                        map.addSource(redId, {
                                            'type': 'geojson',
                                            'data': {
                                                'type': 'Feature',
                                                'geometry': {
                                                    'type': 'Polygon',
                                                    'coordinates': [bay.polygon[0]]
                                                }
                                            }
                                        });
                                        map.addLayer({
                                            'id': redId,
                                            'type': 'fill-extrusion',
                                            'source': redId,
                                            'paint': {
                                                'fill-extrusion-color': '#ff0000',
                                                'fill-extrusion-base': 0,
                                                'fill-extrusion-height': redHeight,
                                                'fill-extrusion-opacity': 0.8
                                            }
                                        });
                                        sectionExtrusions.push(redId);
                                    }
                                    // Green part: from shadowHeight up to house.height
                                    const greenHeight = section.height - bay.shadowHeight;
                                    if (greenHeight > 0) {
                                        const greenId = `bay-green-${i}-${j}`;
                                        map.addSource(greenId, {
                                            'type': 'geojson',
                                            'data': {
                                                'type': 'Feature',
                                                'geometry': {
                                                    'type': 'Polygon',
                                                    'coordinates': [bay.polygon[0]]
                                                }
                                            }
                                        });
                                        map.addLayer({
                                            'id': greenId,
                                            'type': 'fill-extrusion',
                                            'source': greenId,
                                            'paint': {
                                                'fill-extrusion-color': '#00ff00',
                                                'fill-extrusion-base': bay.shadowHeight,
                                                'fill-extrusion-height': section.height,
                                                'fill-extrusion-opacity': 0.8
                                            }
                                        });
                                        sectionExtrusions.push(greenId);
                                    }
                                });
                            });
                            insolationMode = true;
                        }

                        // If we were in 3D buildings mode, regenerate 3D models
                        if (buildings3DMode && building3DGenerator) {
                            // Hide regular buildings
                            generatedBuildings.forEach(id => {
                                if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', 'none');
                            });
                            
                            // Clear existing 3D models and regenerate
                            building3DGenerator.clearModels();
                            try {
                                await building3DGenerator.generateLayout3DModels(layout);
                            } catch (error) {
                                console.error('Error regenerating 3D models:', error);
                                // Fallback to regular buildings
                                generatedBuildings.forEach(id => {
                                    if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', 'visible');
                                });
                                buildings3DMode = false;
                                building3DGenerator.toggle3DMode();
                                document.getElementById('buildings3DMode').textContent = '3D –ó–¥–∞–Ω–∏—è';
                                document.getElementById('buildings3DMode').classList.remove('active');
                            }
                        }

                        // Only adjust camera on first generation
                        if (changeCamera) {
                            const bounds = new mapboxgl.LngLatBounds();
                            layout.sections.forEach(section => {
                                section.polygon[0].forEach(coord => {
                                    bounds.extend(coord);
                                });
                            });

                            // First generation - switch to 3D view
                            map.easeTo({
                                bounds: bounds,
                                padding: 100,
                                maxZoom: 16,
                                duration: 1000,
                                pitch: 45,
                                bearing: -17.6
                            });
                        }
                    }
                } catch (error) {
                    console.error('Error generating buildings:', error);
                    showError('Failed to generate buildings. Please try again later.');
                    
                    // Show details button if we have any logs available (even from a failed attempt)
                    if (currentLogs) {
                        document.getElementById('detailsButton').style.display = 'block';
                    }
                } finally {
                    // Hide loading indicator
                    document.getElementById('loadingIndicator').style.display = 'none';
                }
            });

            // Click handler for toggling
            document.getElementById('buildingsTableToggle').addEventListener('click', function() {
                const panel = document.getElementById('buildingsTablePanel');
                const map = document.getElementById('map');
                
                if (panel.classList.contains('collapsed')) {
                    // Expanding
                    panel.classList.remove('collapsed');
                    map.style.bottom = '200px';
                } else {
                    // Collapsing
                    panel.classList.add('collapsed');
                    map.style.bottom = '40px';
                }
            });

            // Add function to get restrictions for a polygon
            async function getRestrictionsForPolygon(polygonPoints) {
                try {
                    console.log('getRestrictionsForPolygon called with points:', polygonPoints);

                    // Use the OnPostGetRestrictions method instead of API
                    const response = await fetch('?handler=GetRestrictions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        },
                        body: JSON.stringify(polygonPoints),
                        signal: AbortSignal.timeout(300000) // 5 minutes timeout
                    });

                    console.log('Response status:', response.status);

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error('Response error:', errorData);
                        throw new Error(errorData.error || 'Failed to get restrictions');
                    }

                    const data = await response.json();
                    console.log('Restrictions data:', data);

                    if (data.restrictions && data.restrictions.length > 0) {
                        // Display restrictions
                        const restrictionsContainer = document.getElementById('restrictionsContainer');
                        restrictionsContainer.innerHTML = '';

                        data.restrictions.forEach(restriction => {
                            const restrictionDiv = document.createElement('div');
                            restrictionDiv.className = 'restriction-item';
                            restrictionDiv.innerHTML = `
                                <div class="restriction-name">${restriction.properties.name}</div>
                                <div class="restriction-type">${restriction.properties.restrictionType}</div>
                            `;
                            restrictionsContainer.appendChild(restrictionDiv);
                        });

                        document.getElementById('restrictionsList').style.display = 'block';
                        
                        // Return the restrictions data for drawing on map
                        return data.restrictions;
                    } else {
                        document.getElementById('restrictionsList').style.display = 'none';
                        return [];
                    }
                } catch (error) {
                    console.error('Error getting restrictions:', error);
                    // Don't show error to user for restrictions, just hide the list
                    document.getElementById('restrictionsList').style.display = 'none';
                    return [];
                }
            }

            // Function to get color for restriction type
            function getRestrictionColor(restrictionType) {
                switch (restrictionType) {
                    case '–û–ö–ù':
                        return '#ff0000'; // Red
                    case '–û—Ö—Ä–∞–Ω–Ω–∞—è –∑–æ–Ω–∞':
                        return '#ffa500'; // Orange
                    case '–ó–∞—â–∏—Ç–Ω–∞—è –∑–æ–Ω–∞':
                        return '#ffff00'; // Yellow
                    case '–¢–µ—Ä—Ä–∏—Ç–æ—Ä–∏—è –û–ö–ù':
                        return '#ff00ff'; // Magenta
                    default:
                        return '#808080'; // Gray
                }
            }

            // Function to draw restrictions on map
            function drawRestrictions(restrictions) {
                // Safety check for undefined or null restrictions
                if (!restrictions || !Array.isArray(restrictions)) {
                    console.log('drawRestrictions called with invalid restrictions:', restrictions);
                    return;
                }
                
                console.log('drawRestrictions called with', restrictions.length, 'restrictions');
                console.log('Restrictions data:', restrictions);

                // Count geometry types for debugging
                const geometryTypes = {};
                restrictions.forEach(r => {
                    const type = r.geometry.type;
                    geometryTypes[type] = (geometryTypes[type] || 0) + 1;
                });
                console.log('Geometry types found:', geometryTypes);

                // Clear previous restrictions
                const existingRestrictions = map.getStyle().layers
                    ?.filter(layer => layer.id.startsWith('restriction-'))
                    .map(layer => layer.id) || [];
                
                console.log('Clearing existing restrictions:', existingRestrictions);
                existingRestrictions.forEach(id => {
                    if (map.getLayer(id)) map.removeLayer(id);
                    if (map.getSource(id)) map.removeSource(id);
                    
                    // Also remove associated text layers
                    const textId = `${id}-text`;
                    if (map.getLayer(textId)) map.removeLayer(textId);
                });

                // Draw new restrictions
                restrictions.forEach((restriction, index) => {
                    const restrictionId = `restriction-${index}`;
                    const color = getRestrictionColor(restriction.properties.restrictionType);
                    
                    console.log(`Adding restriction ${index}:`, {
                        id: restrictionId,
                        type: restriction.geometry.type,
                        color: color,
                        coordinates: restriction.geometry.coordinates
                    });
                    
                    // Log first few coordinates to check if they're in the right range
                    if (restriction.geometry.coordinates && restriction.geometry.coordinates.length > 0) {
                        const firstCoord = restriction.geometry.coordinates[0];
                        if (Array.isArray(firstCoord) && firstCoord.length > 0) {
                            console.log(`First coordinate: [${firstCoord[0]}, ${firstCoord[1]}]`);
                        }
                    }
                    
                    // Debug: Log the raw restriction object to see its structure
                    console.log('Raw restriction object:', JSON.stringify(restriction, null, 2));
                    
                    // Debug: Inspect the restriction object structure
                    console.log('Restriction keys:', Object.keys(restriction));
                    console.log('Restriction.geometry:', restriction.geometry);
                    console.log('Restriction.geometry.coordinates:', restriction.geometry?.coordinates);
                    console.log('Restriction.geometry.coordinates[0]:', restriction.geometry?.coordinates?.[0]);
                    console.log('Restriction.geometry.coordinates[0][0]:', restriction.geometry?.coordinates?.[0]?.[0]);
                    
                    // Check if coordinates might be in a different property
                    console.log('All restriction properties:', restriction);
                    
                    // Construct GeoJSON Feature object like we do with buildings
                    const geoJsonFeature = {
                        'type': 'Feature',
                        'properties': {
                            'restrictionType': restriction.properties.restrictionType,
                            'name': restriction.properties.name || '',
                            'color': color
                        },
                        'geometry': {
                            'type': restriction.geometry.type,
                            'coordinates': null // Will be set below
                        }
                    };
                    
                    // Handle coordinates - backend already returns them in correct GeoJSON format
                    if (restriction.geometry.type === 'Polygon') {
                        // Backend already returns [[[lng, lat], [lng, lat], ...]] format
                        geoJsonFeature.geometry.coordinates = restriction.geometry.coordinates;
                    } else if (restriction.geometry.type === 'MultiPolygon') {
                        // Backend already returns [[[[lng, lat], [lng, lat], ...]], [[[lng, lat], [lng, lat], ...]]] format
                        geoJsonFeature.geometry.coordinates = restriction.geometry.coordinates;
                    } else if (restriction.geometry.type === 'LineString') {
                        // Backend already returns [[lng, lat], [lng, lat], ...] format
                        geoJsonFeature.geometry.coordinates = restriction.geometry.coordinates;
                    } else if (restriction.geometry.type === 'Point') {
                        // Backend already returns [lng, lat] format
                        geoJsonFeature.geometry.coordinates = restriction.geometry.coordinates;
                    }
                    
                    console.log('Constructed GeoJSON feature:', geoJsonFeature);
                    
                    map.addSource(restrictionId, {
                        'type': 'geojson',
                        'data': geoJsonFeature
                    });

                    if (restriction.geometry.type === 'Polygon' || restriction.geometry.type === 'MultiPolygon') {
                        map.addLayer({
                            'id': restrictionId,
                            'type': 'fill',
                            'source': restrictionId,
                            'paint': {
                                'fill-color': color,
                                'fill-opacity': 0.7
                            }
                        });
                        console.log(`Added fill layer for ${restrictionId}`);
                    } else if (restriction.geometry.type === 'LineString') {
                        map.addLayer({
                            'id': restrictionId,
                            'type': 'line',
                            'source': restrictionId,
                            'paint': {
                                'line-color': color,
                                'line-width': 5
                            }
                        });
                        console.log(`Added line layer for ${restrictionId}`);
                    } else if (restriction.geometry.type === 'Point') {
                        map.addLayer({
                            'id': restrictionId,
                            'type': 'circle',
                            'source': restrictionId,
                            'paint': {
                                'circle-color': color,
                                'circle-radius': 8,
                                'circle-stroke-color': '#000',
                                'circle-stroke-width': 2
                            }
                        });
                        console.log(`Added circle layer for ${restrictionId}`);
                        
                        // Add text label for –û–ö–ù points
                        if (restriction.properties.restrictionType === '–û–ö–ù') {
                            const textId = `${restrictionId}-text`;
                            const name = restriction.properties.name || '–û–ö–ù';
                            const shortName = name.length > 50 ? name.substring(0, 47) + '...' : name;
                            
                            map.addLayer({
                                'id': textId,
                                'type': 'symbol',
                                'source': restrictionId,
                                'layout': {
                                    'text-field': shortName,
                                    'text-size': 10,
                                    'text-offset': [0, 1.5],
                                    'text-anchor': 'top',
                                    'text-allow-overlap': false,
                                    'text-ignore-placement': false
                                },
                                'paint': {
                                    'text-color': '#000',
                                    'text-halo-color': '#fff',
                                    'text-halo-width': 1
                                }
                            });
                            console.log(`Added text label for ${restrictionId}: ${shortName}`);
                        }
                    }
                });

                // Populate restrictions list in sidebar
                populateRestrictionsList(restrictions);
            }

            // Function to populate restrictions list in sidebar
            function populateRestrictionsList(restrictions) {
                const restrictionsList = document.getElementById('restrictionsList');
                const restrictionsContainer = document.getElementById('restrictionsContainer');
                
                if (restrictions.length === 0) {
                    restrictionsList.style.display = 'block';
                    restrictionsContainer.innerHTML = '<div class="restriction-item"><div class="restriction-type">–û–ö–ù –∏ –∑–æ–Ω –æ—Ö—Ä–∞–Ω—ã –Ω–∞ —É—á–∞—Ç–∫–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ</div></div>';
                    return;
                }

                // Group restrictions by type
                const groupedRestrictions = {};
                restrictions.forEach(restriction => {
                    const type = restriction.properties.restrictionType;
                    if (!groupedRestrictions[type]) {
                        groupedRestrictions[type] = [];
                    }
                    groupedRestrictions[type].push(restriction);
                });

                // Create HTML for restrictions list - –û–ö–ù first
                let html = '';
                
                // Define the order we want to display restrictions
                const displayOrder = ['–û–ö–ù', '–¢–µ—Ä—Ä–∏—Ç–æ—Ä–∏—è –û–ö–ù', '–û—Ö—Ä–∞–Ω–Ω–∞—è –∑–æ–Ω–∞', '–ó–∞—â–∏—Ç–Ω–∞—è –∑–æ–Ω–∞'];
                
                displayOrder.forEach(type => {
                    if (groupedRestrictions[type] && groupedRestrictions[type].length > 0) {
                        const typeRestrictions = groupedRestrictions[type];
                        html += `<div class="restriction-item">
                            <div class="restriction-type">${type}</div>
                            <div class="restriction-name">–ù–∞–π–¥–µ–Ω–æ: ${typeRestrictions.length}</div>`;
                        
                        // Add individual restriction names for –û–ö–ù type
                        if (type === '–û–ö–ù') {
                            typeRestrictions.forEach(restriction => {
                                const name = restriction.properties.name || type;
                                html += `<div class="restriction-detail">‚Ä¢ ${name}</div>`;
                            });
                        }
                        
                        html += `</div>`;
                    }
                });

                restrictionsContainer.innerHTML = html;
                restrictionsList.style.display = 'block';
            }

            // Handle details button click
            document.getElementById('showDetails').addEventListener('click', function() {
                if (currentLogs) {
                    document.getElementById('detailsContent').innerHTML = currentLogs;
                    const modal = new bootstrap.Modal(document.getElementById('detailsModal'));
                    modal.show();
                }
            });

            // Handle insolation mode toggle
            document.getElementById('insolationMode').onclick = function() {
                if (!insolationMode) {
                    // Hide buildings
                    generatedBuildings.forEach(id => {
                        if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', 'none');
                    });
                    // Draw bay extrusions
                    const layout = currentLayouts.find((l, idx) => document.querySelectorAll('.layout-card')[idx].classList.contains('active')) || currentLayouts[0];
                    layout.sections.forEach((section, i) => {
                        section.bays.forEach((bay, j) => {
                            // Red part: from 0 up to min(shadowHeight, house.height)
                            const redHeight = Math.min(bay.shadowHeight, section.height);
                            if (redHeight > 0) {
                                const redId = `bay-red-${i}-${j}`;
                                map.addSource(redId, {
                                    'type': 'geojson',
                                    'data': {
                                        'type': 'Feature',
                                        'geometry': {
                                            'type': 'Polygon',
                                            'coordinates': [bay.polygon[0]]
                                        }
                                    }
                                });
                                map.addLayer({
                                    'id': redId,
                                    'type': 'fill-extrusion',
                                    'source': redId,
                                    'paint': {
                                        'fill-extrusion-color': '#ff0000',
                                        'fill-extrusion-base': 0,
                                        'fill-extrusion-height': redHeight,
                                        'fill-extrusion-opacity': 0.8
                                    }
                                });
                                sectionExtrusions.push(redId);
                            }
                            // Green part: from shadowHeight up to min(shadowHeight, house.height)
                            const greenHeight = section.height - bay.shadowHeight;
                            if (greenHeight > 0) {
                                const greenId = `bay-green-${i}-${j}`;
                                map.addSource(greenId, {
                                    'type': 'geojson',
                                    'data': {
                                        'type': 'Feature',
                                        'geometry': {
                                            'type': 'Polygon',
                                            'coordinates': [bay.polygon[0]]
                                        }
                                    }
                                });
                                map.addLayer({
                                    'id': greenId,
                                    'type': 'fill-extrusion',
                                    'source': greenId,
                                    'paint': {
                                        'fill-extrusion-color': '#00ff00',
                                        'fill-extrusion-base': bay.shadowHeight,
                                        'fill-extrusion-height': section.height,
                                        'fill-extrusion-opacity': 0.8
                                    }
                                });
                                sectionExtrusions.push(greenId);
                            }
                        });
                    });
                    insolationMode = true;
                    document.getElementById('insolationMode').textContent = '–û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º';
                    document.getElementById('insolationMode').classList.add('active');
                } else {
                    // Remove section extrusions
                    sectionExtrusions.forEach(id => {
                        if (map.getLayer(id)) map.removeLayer(id);
                        if (map.getSource(id)) map.removeSource(id);
                    });
                    sectionExtrusions = [];
                    
                    // Show buildings
                    generatedBuildings.forEach(id => {
                        if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', 'visible');
                    });
                    
                    insolationMode = false;
                    document.getElementById('insolationMode').textContent = '–ò–Ω—Å–æ–ª—è—Ü–∏—è';
                    document.getElementById('insolationMode').classList.remove('active');
                }
            };

            // Handle 3D buildings mode toggle
            document.getElementById('buildings3DMode').onclick = async function() {
                console.log('3D buildings button clicked, current mode:', buildings3DMode);
                console.log('building3DGenerator:', building3DGenerator);
                console.log('currentLayouts:', currentLayouts);
                
                if (!buildings3DMode) {
                    // Enable 3D buildings mode
                    buildings3DMode = building3DGenerator.toggle3DMode();
                    console.log('3D mode enabled:', buildings3DMode);
                    
                    if (buildings3DMode && currentLayouts) {
                        // Hide regular buildings
                        generatedBuildings.forEach(id => {
                            if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', 'none');
                        });
                        
                        // Generate 3D models
                        const activeLayout = currentLayouts.find((l, idx) => 
                            document.querySelectorAll('.layout-card')[idx].classList.contains('active')
                        ) || currentLayouts[0];
                        
                        console.log('Active layout for 3D generation:', activeLayout);
                        
                        try {
                            await building3DGenerator.generateLayout3DModels(activeLayout);
                            document.getElementById('buildings3DMode').textContent = '–û–±—ã—á–Ω—ã–µ –∑–¥–∞–Ω–∏—è';
                            document.getElementById('buildings3DMode').classList.add('active');
                        } catch (error) {
                            console.error('Error generating 3D buildings:', error);
                            buildings3DMode = false;
                            building3DGenerator.toggle3DMode();
                        }
                    }
                } else {
                    // Disable 3D buildings mode
                    buildings3DMode = building3DGenerator.toggle3DMode();
                    console.log('3D mode disabled:', buildings3DMode);
                    
                    // Clear 3D models
                    building3DGenerator.clearModels();
                    
                    // Show regular buildings
                    generatedBuildings.forEach(id => {
                        if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', 'visible');
                    });
                    
                    document.getElementById('buildings3DMode').textContent = '3D –ó–¥–∞–Ω–∏—è';
                    document.getElementById('buildings3DMode').classList.remove('active');
                }
            };
        }
    </script>
}